TP1

Question 1 : 

	 - Dvector x; x = Dvector (3, 1.);

L'expression ci-dessus fait une affectation par copie. Le problème est que x et Dvector(3, 1.) auront la meme adresse mémoire, ainsi lors de la libération, on obtient un "double free". 
Pour résoudre ce problème, il conviendrait de surcharger l'opérateur "=" qui copierait la valeur de l'objet dans x.

     	 - Dvector x = Dvector (3, 1.);

L'expression ci-dessus utilise un constructeur par copie (implicitement). Ce dernier ayant été surchargé, l'expression fonctionne correctement. En effet, on copie la taille puis chacun des membres du vecteur un par un dans un nouvel objet vecteur. 

TP2

Question 2 :

	- Dvector operator+ (Dvector a, Dvector b)

L'expression ci-dessus utilise directement les variables passées en paramètre. On ne précise pas que les variables doivent être inchangées lors de l'appel. Ainsi, on pourrait donc avoir comme effet de bord, des modifications de a et b, ce qui n'est pas l'effet recherché.  

	- Dvector operator+ (const Dvector &a, const Dvector &b)

Ici, on passe les paramètres par référence en spécifiant qu'ils sont non-modifiables. Au cours de l'appel, des variables locales seront crées auxquelles les valeurs de a et b seront affectées. Le passage par référence permet aussi d'améliorer la vitesse d'accès aux données de la variable source. 

Question 4 :

Nous avons identifiés des groupes d'opérateurs/fonctions permettants des factorisations de codes. 

Ceux que nous avons factorisés:

Nous utilisons l'opérateur d'affectation dans le constructeur par copie. 
La fonctions display et l'opérateur << étant clairement liés, nous utilisons la fonction dans ce dernier (l'inverse était aussi possible).
Le moins unaire utilise le *= entre un vecteur et un réel.
Quand cela est judicieux, nous utilisons le moins unaire combiné à l'opérateur d'addition dans l'implémentation de l'opérateur de soustraction. De plus, nous réutilisons un opérateur lors de l'implémentation de ce même opérateur avec des membres différents. Par exemple, l'addition avec un vecteur à gauche et un réel ainsi que l'addition avec un vecteur à droite et un réel. 
Pour chacun des opérateurs +, *, /, - nous utilisons les opérateurs internes associés +=, *=, /=, -= combinés au constructeur par copie. 
Bien entendu, l'opérateur d'accession est utilisé dès que cela est necessecaire. 

Les autres factorisations possibles:

Nous avons préféré gérer l'implémentation de la fonction resize sans utiliser de factorisation pour limiter les erreurs. Cependant, on peut constater qu'un factorisation avec l'affectation serait possible. 
Nous aurions aussi pu utiliser l'affectation dans le constructeur avec définition de la taille. 

Question 5 :


